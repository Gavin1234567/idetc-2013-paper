%%%%%%%%%%%%%%%%%%%%%%%%%%% asme2e.tex %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Template for producing ASME-format articles using LaTeX            %
% Written by   Harry H. Cheng                                        %
%              Integration Engineering Laboratory                    %
%              Department of Mechanical and Aeronautical Engineering %
%              University of California                              %
%              Davis, CA 95616                                       %
%              Tel: (530) 752-5020 (office)                          %
%                   (530) 752-1028 (lab)                             %
%              Fax: (530) 752-4158                                   %
%              Email: hhcheng@ucdavis.edu                            %
%              WWW:   http://iel.ucdavis.edu/people/cheng.html       %
%              May 7, 1994                                           %
% Modified: February 16, 2001 by Harry H. Cheng                      %
% Modified: January  01, 2003 by Geoffrey R. Shiflett                %
% Use at your own risk, send complaints to /dev/null                 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%% use twocolumn and 10pt options with the asme2e format
\documentclass[twocolumn,10pt]{asme2e}
\special{papersize=8.5in,11in}
\usepackage{fancyvrb}
\usepackage{graphicx}
\usepackage{amsmath}


%% The class has several options
%  onecolumn/twocolumn - format for one or two columns per page
%  10pt/11pt/12pt - use 10, 11, or 12 point font
%  oneside/twoside - format for oneside/twosided printing
%  final/draft - format for final/draft copy
%  cleanfoot - take out copyright info in footer leave page number
%  cleanhead - take out the conference banner on the title page
%  titlepage/notitlepage - put in titlepage or leave out titlepage
%  
%% The default is oneside, onecolumn, 10pt, final

%%% Replace here with information related to your conference
\confshortname{IDETC/CIE 2013}
\conffullname{the ASME 2013 International Design Engineering Technical Conferences \&\\
              Computers and Information in Engineering Conference}

%%%%% for date in a single month, use
%\confdate{24-28}
%\confmonth{September}
%%%%% for date across two months, use
\confdate{4-7}
\confdate{August}
\confyear{2013}
\confcity{Portland}
\confcountry{USA}

%%% Replace DETC2009/MESA-12345 with the number supplied to you
%%% by ASME for your paper.
\papernum{IDETC/CIE 2013-13470}

%%% You need to remove 'DRAFT: ' in the title for the final submitted version.
\title{DRAFT: Constrained Multibody Dynamics with Python: From Symbolic
Equation Generation to Publication}

%%% first author
\author{Gilbet Gede\thanks{Address all correspondence to this author}, Dale L.
Peterson, Angadh S. Nanjangud, Jason K. Moore, Mont Hubbard
  \affiliation{
    Sports Biomechanics Laboratory\\
    Department of Mechanical and Aerospace Engineering\\
    University of California\\
    Davis, California 95616\\
    Email: \{ggede, dlpeterson, asnanjangud, jkmoor, mhubbard\}@ucdavis.edu
  }
}

\begin{document}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{abstract}
Abstract goes here.
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{INTRODUCTION}
There are many dynamic systems which can be better or more effectively studied
when their equations of motion (EoM) are accessible in a symbolic form. For
equations that may be visually inspected (i.e., of reasonable length),
symbolics are generally preferable because the interrelations of the variables
and constants can give clear understanding to the nature of the problem without
the need for numerical simulation. Many classic problems fit this category,
such as the mass-spring-damper, double pendulum, rolling disc, rattleback, and
tippy-top. The benefits of symbolic equations of motion are not limited to
these basic problems though. Certain larger, more complicated multibody systems
can also be studied more effectively when the equations of motion are available
symbolically. Advanced simplification routines can help reduced the equations
to a human readable form and even if the final equations of motion are too
lengthy for human consumption, the symbolic nature of the intermediate steps to
get to the equation of motion are generally short enough that symbolic checks
can validate the correctness of the derivation. Complex problems regarding
biomechanics, spacecraft dynamics, and single-track vehicles have all been
studied using symbolically formed equations of motion.

Having the symbolic equations of motion available permits numerical simulation,
but also allows for a more basic study of the system in question. It becomes
possible to parametrically study system behavior by examining coefficients in
the differential equations, as well as compute symbolic expressions for
equilibria and symbolic conditions for their stability. The symbolic form also
allows for more complicated tasks, such as analyzing how infinitesimal changes
in system parameters (masses, lengths, inertias) affect the dynamics, studying
lumped parameter discretization sizing, and analyzing how coordinate choices
affect problem complexity or configuration singularities. It also becomes
possible to share the equations of motion in a ``written'' form to other
individuals for collaboration, validation, or comparison reasons. This includes
the ease of sharing with other software packages for multi-domain or
hardware-in-the-loop simulation or for use in optimization or optimal control
problems.

Before adequate computing technology was available, the equations of motion for
multibody dynamics problems were formed by hand. There are many
methodologies to obtain the correct equations of motion (Newton-Euler,
Lagrange, Kane, Hamilton, etc). But all methods are tedious and error-prone
when derived by hand, which limits the size and complexity of systems which can
be studied. It only takes a handful of unique orientations between a small set
of rigid bodies within the system to reach this point of complexity. The
introduction of computer algebra systems (CAS) eases the difficulties in
forming the equations of motion, but does not completely eliminate them. The
details of the symbolic algebra, differentiation, and vector calculus can be
handled by a reliable CAS, eliminating the errors associated with those
operations, allowing the user to think more about the implications of the
dynamic equations and less about their correct derivation. Furthermore, since
the formulation of the symbolic equations of motion is done in software, the
equations of motion are immediately available for other computations that make
use of the equations.

The software presented herein described addresses the limitations of hand
derivations and allows for the study of complex multibody dynamics problems
from a symbolic point of view. There already exist software packages which
similarly meet these limited criteria [Autolev/MotionGenesis,
AutoSim/VehicleSim, others?]. But when developing our software, we also
included several other unique requirements:
\begin{enumerate}
  \item The software should be open source with a liberal license, encourage
  meritocracy based collaborative development, and ensure continued project
  development is not limited to or controlled by one any individual or company
  and allow easy integration and use by other projects.

  \item The software should be written in a popular high level programming
  language that balances efficient execution speed with efficient programmer
  development time, and has a wide selection of scientific libraries (or can
  conveniently interface with libraries written in other languages).

  \item The software should be built on top of an existing full-featured
  symbolic CAS that is also open source.

  \item The software should easily export the equations in formats that are
  publication friendly (i.e., \LaTeX) or are compatible with other populer
  computing platforms and languages (i.e., modelica, C/C++/Fortan, MATLAB).
\end{enumerate}
To meet these criteria, we selected Python as the programming language to
implement our software.  Python is interactive, high level, easy to learn,
widely available, widely used (it is one of the top four languages supported at
Google), cross platform, open source, and has a large scientific user base
[SciPy,NumFocus or something in particular?].  Our software is distributed as a
sub-package of SymPy [cite SymPy], which is a full featured CAS written in
Python.  SymPy is is part of the SciPy Stack [citation needed] specification,
so it is included with all scientific Python distributions including popular
ones such as Enthought, Sage, Anaconda, and Python(x,y). SymPy is one of the
more actively developed Python packages with a large number of maintainers,
with a likely long future ahead of it. The SymPy development model allows us to
include whatever functionality we need and allows for other users to view our
code, suggest additional abilities, and improve upon and add to what we have
already done, as well as ensure that the our code is constantly tested against
any changes or updates to the base symbolic functionality offered by SymPy.

In this paper, we discuss two main topics: 1. the interface to the EoM
generation sub-package sympy.physics.mechanics, and 2. the workflow for
analyzing multibody dynamic systems from derivation to simulation and
visualization, which we call PyDy, an acronym for Python Dynamics. We will
explore these two topics through an explanation of the software design and by
demonstrating a test problem which displays software functionality and usage,
how our software is incorporated into a workflow for analyzing dynamic systems,
and the results of these processes. We will then discuss a number of other
features, internal constructions within our software, and verification with
benchmark examples.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{DEMONSTRATION PROBLEM}
To demonstrate the value of PyDy, we have chosen a test problem which
demonstrates its strengths.
The problem is shown in figure (X).
It is a N-pendulum system - a series of N masses each connected by masses links
subjected to a gravitational field.

(Make a figure)

We picked this problem because it is non-trivial, demonstrates the benefits of
having the EoM generation code being written in a full-featured programming
language, and can be written concisely.
When writing the problem by hand, the angular velocity of each and every link
needs to be found, as well as the velocity of each connection.
As the velocity of each connecting point is built off the previous links
connecting point, each additional link has an increasingly large velocity (in
terms of expression size) associated with it.
This is briefly shown in equations (x through x).
(write equation for ang vel and vel, for a few connected links)

When using our software to generate the EoM, the user needs to set the angular
velocity of each link’s reference frame relative to another reference frame,
they need to use a function to find the velocity of each point as a function of
the previous points velocity, list the gravitational forces for each body, and
then supply the problem to the object which generates the EoM.
This certainly sounds complicated, but the code below shows what it actually
looks like.

\begin{figure*}
\fvset{frame=single}
\VerbatimInput{n_pends.py}
\end{figure*}

The equations of motion have now been generated.
In order to do anything useful though, we need to output and examine them.
Within a console, there are commands to display the quantities generated, such
as \begin{verbatim} mpprint \end{verbatim}, which generates the output below, showing the mass matrix of this
problem with $N=2$:

%\begin{figure*}
%\includegraphics[natwidth=470bp, natheight=93bp, width=3in]{mpprint_out.svg}
%\includegraphics[width=3.5in]{mpprint_out.eps}
%\end{figure*}
mpprint graphic

There is also LaTeX output functionality, which generates a string that can be
directly copied/pasted into publications to generate LaTeX math equations (the
same mass matrix is shown):

\begin{equation}
\left[\begin{smallmatrix}l_{0}^{2} m_{0} + l_{0}^{2} m_{1} & l_{0} l_{1} m_{1}
\left(\operatorname{sin}\left(q_{0}\right) \operatorname{sin}\left(q_{1}\right)
+ \operatorname{cos}\left(q_{0}\right)
\operatorname{cos}\left(q_{1}\right)\right)\\l_{0} l_{1} m_{1}
\left(\operatorname{sin}\left(q_{0}\right) \operatorname{sin}\left(q_{1}\right)
+ \operatorname{cos}\left(q_{0}\right)
\operatorname{cos}\left(q_{1}\right)\right) & l_{1}^{2}
m_{1}\end{smallmatrix}\right]
\end{equation}

Another part of studying dynamic systems is simulation and visualization of the
results.
SymPy can only solve relatively simple ODEs internally, so the equations of
motion generated for more complex systems need to be passed to other numerical
integrators.
Currently, sympy.physics.mechanics can make use of existing SymPy translation
functions, but more advanced options to generate compiled code are being
developed and guided by user demands.
The SymPy translation function [lambdify] can convert symbolic expressions to a
function using NumPy code.
The code below (which follows the previously written code) shows this:

\begin{figure*}
\begin{Verbatim}[frame=single]
# NUMERICAL SIMULATION
from pylab import *
from sympy import Dummy, lambdify
from scipy.integrate import odeint

# Substitution Values
link_m = 0.01 / n
link_l = 1. / n
grav = 9.81
parameter_dict = {g:grav}
for i in range(n):
    parameter_dict.update({l[i]:link_l, m[i]:link_m})
# Used to leave sympy and go to numpy
dummy_symbols = [Dummy() for i in q + u]
temp_dict = dict(zip(q + u, dummy_symbols))
# Actual substition
MM = KM.mass_matrix_full.subs(KM.kindiffdict()).subs(temp_dict).subs(parameter_dict)
Fo = KM.forcing_full.subs(KM.kindiffdict()).subs(temp_dict).subs(parameter_dict)

# Construct the right-hand-side function
m = lambdify(dummy_symbols, MM)
f = lambdify(dummy_symbols, Fo)
def rhs(y, t):
    return array(linalg.solve(m(*y), f(*y))).T[0]

# Initial conditions and time vector
y0 = hstack((arange(n) * 0.01, arange(n) * 0))
t = linspace(0, 10, 1000)

# Integration
y = odeint(rhs, y0, t)


\end{Verbatim}
\end{figure*}

NumPy is an integral part of the larger Scientific Python ecosystem, focusing
primarily on numerical arrays and matrices and operations on these arrays and
matrices.
SciPy is another part of this ecosystem that provides quick and simple Python
wrappers to a large library of scientific FORTRAN code.
The third necessary component of this ecosystem is matplotlib, a Python
plotting library for visualization of the large datasets generated by NumPy and
SciPy code.
Using these three Python packages, we can numerically integrate ODEs and plot
the results.
The following code shows this process and figures (x) show the plots generated:

\begin{figure*}
\begin{Verbatim}[frame=single]
# PLOTTING
for i in range(n):
    figure(1)
    plot(t, y[:, i], label='q'+str(i))
    figure(2)
    plot(t, y[:, i + n], label='u'+str(i))

figure(1)
legend(loc=0)
xlabel('Time (s)')
ylabel('Rotation (rad)')
figure(2)
legend(loc=0)
xlabel('Time (s)')
ylabel('Angular Rate (rad/s)')
show()
\end{Verbatim}
\end{figure*}

Using other Python packages, such as VisualPython, 3D animations can be
created.
Use of human-interface-devices (with a sufficiently fast computer) allows for
real-time interaction between a user and a visualized simulation.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{SOFTWARE VALIDATION}
Anytime new software is developed to generate equations of motion, the
vailidity and accuracy of the software rightly comes into question. We have
addressed these concerns in three ways to ensure that our code does generate
correct equations of motion for arbitrarily complex systems. Firstly, the code
is open source and well documented. This allows anyone to review the code and
check for bugs. Linus's Law ``given enough eyeballs, all bugs
are shallow'' (cite the Cathedral and the Bazaat) applies, if true.
Secondly, the code functionality is heavily tested with unit testing.  That is,
each piece of independent functionality in the code has a test (known
input/output) in place that guarantees correct functioning of each unit. This
helps ensure that not only the current code works as expected, but that future
versions must also pass the tests. Thirdly, we've built in tests for well
benchmarked problems in mutlibody dynamics. There are many problems, both
simple and complex that have well known symbolic solutions. We have chosen
several benchmark problems that include three dimensional, configuration and
motion constraints, and exposing noncontributing forces. These problems are
built in to the test suite for the package.

One degree of freedom mass sprint dampero
two degree of freedom mas sping damper (two particleso
particle pendulum (kane and lagrange)
rolling disc (kane and lagrange)
rolling disc with aux speeds
inverted pendulum on a cart
disc on an inclined plane (lagrange only)
double pendulum (langragne only)
bicycle nonlinear and linear \cite{Meijaard2007} and BasuMandall2007) - not built in as a test

mechanics leverages two interdepedent methods to validate the accuracy of the
tests within sympy: ensures stability/consistency during development
benchmark validations (rolling disc, bicycle, other\ldots)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{USAGE}
%%%%%%%%%%%% JASON BELOW HERE %%%%%%%%%%%%
This section deals with obtaining the software demonstrated in this paper and
the available resources for learning to use it. All of the software
demonstrated in this paper can be readily obtained for free and installed on
virtually any platform. Also, all of the packages are liberally licensed with a
BSD or compatible license and either stable releases or development branches
can be downloaded.

To obtain and use the core \verb|mechanics| package for symbolic equation of
motion generation, one must simply download and install Python version 2.5+ and
SymPy version 0.7.2+\footnote{One of the major requirements for code added to
SymPy is that every function and object has to be thoroughly tested and
documented. SymPy has over 88\% of its code tested by the automated unit-tests.
This ensures that no update causes regressions or breaks current functionality.
Generally, the SymPy development branch is more stable and contains less bugs
than the numbered releases.}. Download and installation instructions for each
can be found on the softwares' respective web sites, www.python.org and
www.sympy.org.

To run a full PyDy example from equation of motion generation to simulation and
visualization, Python and at least the scientific Python (SciPy) software stack
http://scipy.github.com/stackspec.html must be obtained. We make use of these
packages in the SciPy stack in the previous demo problem:
%
\begin{itemize}
  \item SymPy: http://sympy.org/
  \item NumPy: http://www.numpy.org/
  \item SciPy: http://www.scipy.org/
  \item matplotlib: http://matplotlib.org/
\end{itemize}
%
Download and installation instructions for various platforms are available on
their respective web sites. But it is worth noting that these packages are a
part of most of the widely used scientific Python distributions. Downloading a
distribution binary is generally the easiest method of installing \emph{all} of
the needed software, especially for a newcomer to the software platform.
Popular scientific distributions that will provide the needed software are
listed below:
%
\begin{itemize}
  \item Enthought: http://www.enthought.com/
  \item Sage: http://www.sagemath.org/
  \item Anaconda: http://continuum.io/
  \item Python(x,y): http://www.pythonxy.com
\end{itemize}
%
SciPy provides more comprehensive installation instructions than space permits
here: http://scipy.github.com/install.html.

The first step in doing multibody dynamics with Python is to get familiar using
\verb|mechanics|\footnote{Some may prefer to learn Python and the SciPy Stack
first, but the authors do not think this is such a necessity. It boils down to
preference and learning style}. The first stop is the SymPy documentation which
is available online at http://docs.sympy.org/. The documentation provides
detailed instructions on installation, has introductory tutorials, lists common
mistakes, details development procedures and the internal architecture, and
contains detailed documentation for all of the subpackages and modules. In
particular, the \verb|mechanics| documentation contains over 60 pages that aim
to provide an overview of using the package and a brief introduction to the
fundamentals dynamics. Several example classic dynamics problems are included
in the documentation and there are even more in the \verb|mechanics.tests|
package. Working through the material in the \verb|mechanics| documentation
will provide the basics of generating the symbolic equations of motion of
multibody systems.

Additionally, a wiki for PyDy is maintained at www.pydy.org. This is a
user-editable guide to solving dynamics problems in Python, and contains
numerous introductory examples that demonstrate the process from system
definition to simulation and visualization, examples of interfacing
\verb|mechanics| with various compiled languages, and more advanced use cases
to demonstrate capabilities. As the PyDy workflow is integrated into more
university courses, the goal is to allow professors, teaching assistants, and
students to utilize, refine, and expand the wiki.

Finally, each of the software packages listed above maintains email lists and
IRC channels for ``live'' help and the communities supporting the software are
quite amicable to beginners. The PyDy Google Group is a good place to start if
you have questions: \verb|https://groups.google.com/forum/?fromgroups#!forum/pydy|.
%
\section*{SOFTWARE DESIGN}
The software design for \verb|mechanics| is influenced by Python's object
oriented nature, the underlying SymPy data types, Kane’s method for generating
equations of motion\cite{Kane1985} for multibody systems, and the proprietary
and now defunct software, Autolev\cite{Kane2000}, which also implemented Kane's
method in a symbolic fashion.

Kane’s method powers many of the dynamic system software packages available
\cite{Sayers1990, Englighten2013} due to its detailed bookkeeping design and
ease of mapping to a computer language. Kane’s method  has influenced the
design of \verb|mechanics| a great deal but we structured the software such
that any equation of motion derivation method could be utilized. This is
possible because we separated the kinematic code from the equations of motion
generation code. We have recently included Lagrange’s method to demonstrate
that unique ability.

SymPy's symbolic manipulation library provides the core functionality for the
mechanics package. The majority of objects that are created when using SymPy
are expression objects, \verb|Expr|.  Other symbolic objects in SymPy, such as
symbols, adds and muls, or exponentials are inherit from the \verb|Expr| class.
The \verb|mechanics| package is dependent on these objects, but not by
inheritance. \verb|mechanics| is made up of a number of classes and functions
spread out over several modules which are explained in the following list:
%
\begin{description}
  \item[essential.py] contains the basic building blocks for working with
    vector calculus and dynamic systems and includes the following classes and
    functions:
    \begin{description}
      \item[ReferenceFrame] is a class that represent a rotational reference
        frame in a dynamic system. \verb|ReferenceFrame| has three orthonormal
        basis unit vectors and manages information about the frame's
        orientation, angular velocity, and angular acceleration relative to
        other reference frames through a direction cosine matrix and velocity
        and acceleration vectors. It is closely interlinked to the
        \verb|Vector| class, i.e. \verb|Vectors| have associated
        \verb|ReferenceFrame|'s and \verb|ReferenceFrames|'s have associated
        \verb|Vector|'s.
      \item[Vector] is a class that represents a generic three dimensional
        vector built from components in multiple frames of reference. Vectors
        support all of the common operations as one would expect such as
        addition, subtraction, multiplication, division, dot products, cross
        products, outer products, and re-expression into different frames of
        reference.
      \item[Dyadic] is a class that represents a generic Dyadic. Dyadics are
        used in this software as a basis independent method of defining an
        inertia tensor. Dyadics support all of the common operations, much
        similar to the Vector class.
      \item[dynamicsymbols] is a function that is used to ease the generation
        of time dependent variables and their derivatives. This variables are
        created as SymPy \verb|UndefinedFunction|s. It is used the same fashion
        as SymPy general \verb|symbol| function. The standard variable for time
        can be set to something other than the default, \verb|t|.
    \end{description}
  \item[point.py] contains the \verb|Point| class. This class manages
    and tracks the location, velocity, and acceleration of a point in space
    relative to another point. It also provides some convenience methods to set
    velocities and accelerations via the one point and two point theories
    \cite{Kane1985}.
  \item[functions.py] contains an assortment of convenience functions. For
    example there is a function for generating inertia dyadics from tensor
    notation, a function that outputs kinematical differential equations for
    various body or spaced fixed coordinates and speeds, functions to generate
    linear and angular momenta or kinetic and potential energies for a general
    system of particles and bodies, among others.
  \item[particle.py] contains the \verb|Particle| class which functions as a
    container class for a point and an associated mass. It also has methods for
    computing momentum and energy.
  \item[rigidbody.py] contains the \verb|RigidBody| is analogous to the
    \verb|Particle| class but for rigid bodies and contains mass, mass center,
    inertia, and a reference frame associated with the rigid body. It also has
    methods for momentum and energy.
  \item[kane.py] contains the \verb|KanesMethod| class which automates the
    generation of a system's non-linear equations of motion using Kane's
    method\cite{Kane1985} and linear equations of motion using the method
    presented in \cite{Peterson2013}. A \verb|KanesMethod| object is initialized
    with an inertial reference frame, set of particles and/or rigid bodies, a
    set of forces and torques acting on the system, the desired kinematical
    differential equations, the desired independent and dependent generalized
    speeds, any configuration constraints, any velocity constraints, and any
    auxiliary speeds needed to compute non-contributing forces.
  \item[lagrange.py] contains the \verb|LagrangesMethod| class with automates
    the generation of a system's non-linear equations of motion via the methods
    of Lagrangian mechanics \cite{Crandall1968}. A \verb|LagrangesMethod|
    object is initialized with a Lagrangian and the desired generalized
    coordinates and optionally forces acting on the system, velocity
    constraints, and an inertial reference frame. If velocity constraints are
    supplied, Lagrange multipliers are generated to account for them and
    non-conservative forces are properly handled if applied they affect the
    system.
\end{description}

%%%%%%%%%%%% JASON ABOVE HERE %%%%%%%%%%%%
%%%%%%%%%%%% GILBERT BELOW HERE %%%%%%%%%%
As previously shown, the submodule essential.py (which is the core of
sympy.physics.mechanics) is made of \verb|ReferenceFrame|, \verb|Vector|,
\verb|Dyadic|, and \verb|dynamicsymbols| (as well as some output functions).
These classes will be explained in some detail, to allow for a greater
understanding of how our software was written and how it functions.

Firstly, \verb|dynamicsymbols| will be explained - it is merely a shortcut to
producing quantities which are functions of time.
It is included in essential for 2 reasons: one has to do with Python importing
requirements, and the other is that \verb|dynamicsymbols| defines the symbol
used to represent time (default ``t'').
All of the vector calculus methods assume that functions of time define
rotations between \verb|ReferenceFrame|s; if basic symbols or expressions which
are not functions of time are supplied, they will be treated as constants when
differentiating with respect to time.

The relationship between \verb|ReferenceFrame| and \verb|Vector| is very
complex; we will describe it here using visual aids.
Upon initialization, a \verb|ReferenceFrame| has 3 vectors which are created,
representing the basis vectors of that reference frame.
A \verb|Vector| is made up of a list of segments per frame; for each unique
\verb|ReferenceFrame| involved in the definition of a vector, one element in
this list exists.
Each element in the list contains the associated \verb|ReferenceFrame| and a
$3\times1$ SymPy matrix representing the measure numbers for each frame.
The basis vectors which are created upon \verb|ReferenceFrame| initialization
therefore have a list of length 1, made up of the \verb|ReferenceFrame| they
are created for and the matrix with one element equal to 1 and two elements
equal to 0. Figure (x) shows this relationship.

As objects, both these basis vectors and other vectors are instances of the
same \verb|Vector| class.
More complicated \verb|Vector|s just consist of longer lists, and matrices
which are not as basic; more frames can be introduced by adding vectors
together or performing more advanced vector and vector calculus operations.
Figure (x) shows how \verb|Vector| has its information stored.

The final two parts of \verb|Vector|'s design are in the users interaction with
these objects - creating and displaying them.
Direct initialization of a \verb|Vector| object by a user should never take
place; more complicated vectors will be formed out of basis vectors from the
\verb|ReferenceFrame|s and operations between \verb|Vector|s.
When displaying a \verb|Vector| object to the user, the complex implementation
details of each instance are masked.
Instead, the user only sees something along the following lines:
\begin{verbatim}
- l0*u0**2*A0.x + l0*u0'*A0.y - l1*u1**2*A1.x + l1*u1'*A1.y
\end{verbatim}
Each measure number and accompanying basis vector are printed out in a way that
the output can be copied and reentered to form the \verb|Vector| again.
This leaves our \verb|Vector| class as a symbolic object (although, not a
subclass of the main SymPy \verb|Expr| class) which users will interact with on
a symbolic/mathematical level; the complex initialization should never have to
be done by hand, making use of this class easy for people not intimately
familiar with Python and SymPy.


%
%How do these classes interact with each other (probably figures)?
%    DONE except fig      ReferenceFrame/Vector \& Dyadic interactions (detailing essential.py, visually)
%    ReferenceFrame Tree (how a tree is formed, possible pitfalls)
%    DONE except fig      Vector Assemblage (vector is a list of parts of frames and frames - shown visually)
%    Point Tree (similar to RF)
%
%How is this translated into equations?
%    container classes (Particle, RigidBody)
%    KanesMethod/LagrangesMethod
%        Describe the classes and their methods, probably a page for each class. At least give the basic understanding of how the classes work.
%        Talk about the methods for constraints and auxiliary speeds.
%        mass matrix
%        cite the paper that Luke and Gilbert wrote about linearization instead of writing about those methods here
%        Explain the form of the EoMs that these methods produce and speak some on solving them for the u dots and the pitfalls associate with that, why it may be better to do it numerically

%%%%%%%%%%%% GILBERT ABOVE HERE %%%%%%%%%%
%%%%%%%%%%%% ANGADH BELOW HERE %%%%%%%%%%%

%%%%%%%%%%%% ANGADH ABOVE HERE %%%%%%%%%%%

\section*{CONCLUSIONS}

\section*{ACKNOWLEDGEMENTS}
Three Google Summer of Code grants (2009, 2011, 2012) most of the software
development. This material is also partially based upon work supported by the
National Science Foundation under Grant No. 0928339. Any opinions, findings,
and conclusions or recommendations expressed in this material are those of the
author(s) and do not necessarily reflect the views of the National Science
Foundation.
\bibliographystyle{asmems4}
\bibliography{asme2e}
\end{document}
