%%%%%%%%%%%%%%%%%%%%%%%%%%% asme2e.tex %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Template for producing ASME-format articles using LaTeX            %
% Written by   Harry H. Cheng                                        %
%              Integration Engineering Laboratory                    %
%              Department of Mechanical and Aeronautical Engineering %
%              University of California                              %
%              Davis, CA 95616                                       %
%              Tel: (530) 752-5020 (office)                          %
%                   (530) 752-1028 (lab)                             %
%              Fax: (530) 752-4158                                   %
%              Email: hhcheng@ucdavis.edu                            %
%              WWW:   http://iel.ucdavis.edu/people/cheng.html       %
%              May 7, 1994                                           %
% Modified: February 16, 2001 by Harry H. Cheng                      %
% Modified: January  01, 2003 by Geoffrey R. Shiflett                %
% Use at your own risk, send complaints to /dev/null                 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%% use twocolumn and 10pt options with the asme2e format
\documentclass[twocolumn,10pt]{asme2e}
\special{papersize=8.5in,11in}
\usepackage{fancyvrb}
\usepackage{graphicx}
\usepackage{amsmath}
\renewcommand{\b}[1]{ \mathbf{ #1 } }
\newcommand{\bs}[1]{ \boldsymbol{ #1 } }


%% The class has several options
%  onecolumn/twocolumn - format for one or two columns per page
%  10pt/11pt/12pt - use 10, 11, or 12 point font
%  oneside/twoside - format for oneside/twosided printing
%  final/draft - format for final/draft copy
%  cleanfoot - take out copyright info in footer leave page number
%  cleanhead - take out the conference banner on the title page
%  titlepage/notitlepage - put in titlepage or leave out titlepage
%  
%% The default is oneside, onecolumn, 10pt, final

%%% Replace here with information related to your conference
\confshortname{IDETC/CIE 2013}
\conffullname{the ASME 2013 International Design Engineering Technical Conferences \&\\
              Computers and Information in Engineering Conference}

%%%%% for date in a single month, use
%\confdate{24-28}
%\confmonth{September}
%%%%% for date across two months, use
\confdate{4-7}
\confdate{August}
\confyear{2013}
\confcity{Portland}
\confcountry{USA}

%%% Replace DETC2009/MESA-12345 with the number supplied to you
%%% by ASME for your paper.
\papernum{IDETC/CIE 2013-13470}

%%% You need to remove 'DRAFT: ' in the title for the final submitted version.
\title{DRAFT: Constrained Multibody Dynamics with Python: From Symbolic
Equation Generation to Publication}

%%% first author
\author{Gilbet Gede\thanks{Address all correspondence to this author}, Dale L.
Peterson, Jason K. Moore, Angadh S. Nanjangud, Mont Hubbard
  \affiliation{
    Sports Biomechanics Laboratory\\
    Department of Mechanical and Aerospace Engineering\\
    University of California\\
    Davis, California 95616\\
    Email: \{ggede, dlpeterson, jkmoor, asnanjangud, mhubbard\}@ucdavis.edu
  }
}

\begin{document}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{abstract}
Abstract goes here.
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{INTRODUCTION}
There are many dynamic systems which can be better or more effectively studied
when their equations of motion (EoM) are accessible in a symbolic form. For
equations that may be visually inspected (i.e., of reasonable length),
symbolics are generally preferable because the interrelations of the variables
and constants can give clear understanding to the nature of the problem without
the need for numerical simulation. Many classic problems fit this category,
such as the mass-spring-damper, double pendulum, rolling disc, rattleback, and
tippy-top. The benefits of symbolic equations of motion are not limited to
these basic problems though. Certain larger, more complicated multibody systems
can also be studied more effectively when the equations of motion are available
symbolically. Advanced simplification routines can help reduced the equations
to a human readable form and even if the final equations of motion are too
lengthy for human consumption, the symbolic nature of the intermediate steps to
get to the equation of motion are generally short enough that symbolic checks
can validate the correctness of the derivation. Complex problems regarding
biomechanics, spacecraft dynamics, and single-track vehicles have all been
studied using symbolically formed equations of motion.

Having the symbolic equations of motion available permits numerical simulation,
but also allows for a more basic study of the system in question. It becomes
possible to parametrically study system behavior by examining coefficients in
the differential equations, as well as compute symbolic expressions for
equilibria and symbolic conditions for their stability. The symbolic form also
allows for more complicated tasks, such as analyzing how infinitesimal changes
in system parameters (masses, lengths, inertias) affect the dynamics, studying
lumped parameter discretization sizing, and analyzing how coordinate choices
affect problem complexity or configuration singularities. It also becomes
possible to share the equations of motion in a ``written'' form to other
individuals for collaboration, validation, or comparison reasons. This includes
the ease of sharing with other software packages for multi-domain or
hardware-in-the-loop simulation or for use in optimization or optimal control
problems.

Before adequate computing technology was available, the equations of motion for
multibody dynamics problems were formed by hand. There are many
methodologies to obtain the correct equations of motion (Newton-Euler,
Lagrange, Kane, Hamilton, etc). But all methods are tedious and error-prone
when derived by hand, which limits the size and complexity of systems which can
be studied. It only takes a handful of unique orientations between a small set
of rigid bodies within the system to reach this point of complexity. The
introduction of computer algebra systems (CAS) eases the difficulties in
forming the equations of motion, but does not completely eliminate them. The
details of the symbolic algebra, differentiation, and vector calculus can be
handled by a reliable CAS, eliminating the errors associated with those
operations, allowing the user to think more about the implications of the
dynamic equations and less about their correct derivation. Furthermore, since
the formulation of the symbolic equations of motion is done in software, the
equations of motion are immediately available for other computations that make
use of the equations.

The software presented herein described addresses the limitations of hand
derivations and allows for the study of complex multibody dynamics problems
from a symbolic point of view. There already exist software packages which
similarly meet these limited criteria [Autolev/MotionGenesis,
AutoSim/VehicleSim, others?]. But when developing our software, we also
included several other unique requirements:
\begin{enumerate}
  \item The software should be open source with a liberal license, encourage
  meritocracy based collaborative development, and ensure continued project
  development is not limited to or controlled by one any individual or company
  and allow easy integration and use by other projects.

  \item The software should be written in a popular high level programming
  language that balances efficient execution speed with efficient programmer
  development time, and has a wide selection of scientific libraries (or can
  conveniently interface with libraries written in other languages).

  \item The software should be built on top of an existing full-featured
  symbolic CAS that is also open source.

  \item The software should easily export the equations in formats that are
  publication friendly (i.e., \LaTeX) or are compatible with other populer
  computing platforms and languages (i.e., modelica, C/C++/Fortan, MATLAB).
\end{enumerate}
To meet these criteria, we selected Python as the programming language to
implement our software.  Python is interactive, high level, easy to learn,
widely available, widely used (it is one of the top four languages supported at
Google), cross platform, open source, and has a large scientific user base
[SciPy,NumFocus or something in particular?].  Our software is distributed as a
sub-package of SymPy [cite SymPy], which is a full featured CAS written in
Python.  SymPy is is part of the SciPy Stack [citation needed] specification,
so it is included with all scientific Python distributions including popular
ones such as Enthought, Sage, Anaconda, and Python(x,y). SymPy is one of the
more actively developed Python packages with a large number of maintainers,
with a likely long future ahead of it. The SymPy development model allows us to
include whatever functionality we need and allows for other users to view our
code, suggest additional abilities, and improve upon and add to what we have
already done, as well as ensure that the our code is constantly tested against
any changes or updates to the base symbolic functionality offered by SymPy.

In this paper, we discuss two main topics: 1. the interface to the EoM
generation sub-package sympy.physics.mechanics, and 2. the workflow for
analyzing multibody dynamic systems from derivation to simulation and
visualization, which we call PyDy, an acronym for Python Dynamics. We will
explore these two topics through an explanation of the software design and by
demonstrating a test problem which displays software functionality and usage,
how our software is incorporated into a workflow for analyzing dynamic systems,
and the results of these processes. We will then discuss a number of other
features, internal constructions within our software, and verification with
benchmark examples.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{DEMONSTRATION PROBLEM}
We demonstrate the value of PyDy through the derivation of the $N$-pendulum
system shown in Figure (\ref{fig:n_pendulum}).  The system is defined by $N$
massless links of length $l_i$ with particles of mass $m_i$ fixed at one end.
We selected this problem because it illustrates the power and utility of having
EoM generation code available within a full-featured programming language.  The
angular velocity of each and every link must be found, as well as the velocity
of each mass center.  The velocity of $i$-th mass center is
\begin{align*}
%\omega_i &= u_i \cdot a_z\\
v_i &= v_{i-1} + \omega_i \times r^i \qquad (i = 1,\dots,N)
\end{align*}
This nesting of velocities is best addressed with a classic for loop, something
that is ideally suited for a computer (loop unrolling is difficult by hand when
there are many steps and $N$ is large).  The 37 lines of source code required
to derive the dynamic equations of motion for the $N$ pendulum, where $N$ is
arbitrary, is shown in (\ref{fig:n_pendulum_source}).

The script first imports necessary functions and classes, then declares a
number of symbolic variables that represent generalized coordinates,
generalized speeds, constant parameters, reference frames, points and
particles. A few empty lists are created before the for loop is entered; these
lists are sequentially populated as the for loop procedes.  When the final
iteration of the for loop is complete, the kinematics and all active forces of
the problem have been completely specified.  The last two lines of the script
take this specification of kinematics and dynamics and generate Kane's
dynamical equations of motion ($F_r + F_r^* = 0$) in symbolic form.  At this
point, these equations may be manipulated as fully symbolic variables for a
variety of purposes.  For example, the command \verb|mlatex(frstar)| generates
\LaTeX code for the generalized active force $F_r$ which renders as
\begin{equation}
\left[\begin{smallmatrix}g l_{0} m_{0} \operatorname{sin}\left(q_{0}\right) + g l_{0} m_{1} \operatorname{sin}\left(q_{0}\right) + g l_{0} m_{2} \operatorname{sin}\left(q_{0}\right) + g l_{0} m_{3} \operatorname{sin}\left(q_{0}\right)\\g l_{1} m_{1} \operatorname{sin}\left(q_{1}\right) + g l_{1} m_{2} \operatorname{sin}\left(q_{1}\right) + g l_{1} m_{3} \operatorname{sin}\left(q_{1}\right)\\g l_{2} m_{2} \operatorname{sin}\left(q_{2}\right) + g l_{2} m_{3} \operatorname{sin}\left(q_{2}\right)\\g l_{3} m_{3} \operatorname{sin}\left(q_{3}\right)\end{smallmatrix}\right]
\end{equation}
with no further modification from the user.

\begin{figure*}
(Luke will make a figure)
\caption{N-pendulum system, a sequence of massive links connected by revolute
joints subjected to a gravitational field.}
\label{fig:n_pendulum}
\end{figure*}

\begin{figure*}
\fvset{frame=single}
\VerbatimInput{n_pends_minimal.py}
\caption{User Python script to derive equations of motion for N-pendulum}
\label{fig:n_pendulum_source}
\end{figure*}

There are other options besides \LaTeX output which are useful.  Within a
console, commands to ``pretty print'' symbolic expressions can be performed
with \verb|mpprint()|, which generates the output below, showing the mass
matrix of the $N$-pendulum for $N=2$:

%\begin{figure*}
%\includegraphics[natwidth=470bp, natheight=93bp, width=3in]{mpprint_out.svg}
%\includegraphics[width=3.5in]{mpprint_out.eps}
%\end{figure*}
mpprint graphic

Another part of studying dynamic systems is simulation and visualization of the
results.  SymPy can only solve relatively simple ODEs internally, so the
equations of motion generated for more complex systems need to be passed to
other numerical integrators.  Currently, sympy.physics.mechanics can make use
of existing SymPy translation functions, but more advanced options to generate
compiled code are being developed and guided by user demands.  The SymPy
translation function [lambdify] can convert symbolic expressions to a function
using NumPy code.  The code below (which follows the previously written code)
shows this:

\begin{figure*}
\begin{Verbatim}[frame=single]
# NUMERICAL SIMULATION
from pylab import *
from sympy import Dummy, lambdify
from scipy.integrate import odeint

# Substitution Values
link_m = 0.01 / n
link_l = 1. / n
grav = 9.81
parameter_dict = {g:grav}
for i in range(n):
    parameter_dict.update({l[i]:link_l, m[i]:link_m})
# Used to leave sympy and go to numpy
dummy_symbols = [Dummy() for i in q + u]
temp_dict = dict(zip(q + u, dummy_symbols))
# Actual substition
MM = KM.mass_matrix_full.subs(KM.kindiffdict()).subs(temp_dict).subs(parameter_dict)
Fo = KM.forcing_full.subs(KM.kindiffdict()).subs(temp_dict).subs(parameter_dict)

# Construct the right-hand-side function
m = lambdify(dummy_symbols, MM)
f = lambdify(dummy_symbols, Fo)
def rhs(y, t):
    return array(linalg.solve(m(*y), f(*y))).T[0]

# Initial conditions and time vector
y0 = hstack((arange(n) * 0.01, arange(n) * 0))
t = linspace(0, 10, 1000)

# Integration
y = odeint(rhs, y0, t)


\end{Verbatim}
\end{figure*}

NumPy is an integral part of the larger Scientific Python ecosystem, focusing
primarily on numerical arrays and matrices and operations on these arrays and
matrices.
SciPy is another part of this ecosystem that provides quick and simple Python
wrappers to a large library of scientific FORTRAN code.
The third necessary component of this ecosystem is matplotlib, a Python
plotting library for visualization of the large datasets generated by NumPy and
SciPy code.
Using these three Python packages, we can numerically integrate ODEs and plot
the results.
The following code shows this process and figures (x) show the plots generated:

\begin{figure*}
\begin{Verbatim}[frame=single]
# PLOTTING
for i in range(n):
    figure(1)
    plot(t, y[:, i], label='q'+str(i))
    figure(2)
    plot(t, y[:, i + n], label='u'+str(i))

figure(1)
legend(loc=0)
xlabel('Time (s)')
ylabel('Rotation (rad)')
figure(2)
legend(loc=0)
xlabel('Time (s)')
ylabel('Angular Rate (rad/s)')
show()
\end{Verbatim}
\end{figure*}

Using other Python packages, such as VisualPython, 3D animations can be
created.
Use of human-interface-devices (with a sufficiently fast computer) allows for
real-time interaction between a user and a visualized simulation.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{SOFTWARE VALIDATION}
Anytime new software is developed to generate equations of motion, the
vailidity and accuracy of the software rightly comes into question. We have
addressed these concerns in three ways to ensure that our code does generate
correct equations of motion for arbitrarily complex systems. Firstly, the code
is open source and well documented. This allows anyone to review the code and
check for bugs. Linus's Law ``given enough eyeballs, all bugs
are shallow'' (cite the Cathedral and the Bazaat) applies, if true.
Secondly, the code functionality is heavily tested with unit testing.  That is,
each piece of independent functionality in the code has a test (known
input/output) in place that guarantees correct functioning of each unit. This
helps ensure that not only the current code works as expected, but that future
versions must also pass the tests. Thirdly, we've built in tests for well
benchmarked problems in mutlibody dynamics. There are many problems, both
simple and complex that have well known symbolic solutions. We have chosen
several benchmark problems that include three dimensional, configuration and
motion constraints, and exposing noncontributing forces. These problems are
built in to the test suite for the package.

One degree of freedom mass sprint dampero
two degree of freedom mas sping damper (two particleso
particle pendulum (kane and lagrange)
rolling disc (kane and lagrange)
rolling disc with aux speeds
inverted pendulum on a cart
disc on an inclined plane (lagrange only)
double pendulum (langragne only)
bicycle nonlinear and linear \cite{Meijaard2007} and BasuMandall2007) - not built in as a test

mechanics leverages two interdepedent methods to validate the accuracy of the
tests within sympy: ensures stability/consistency during development
benchmark validations (rolling disc, bicycle, other\ldots)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{SOFTWARE DESIGN}
%%%%%%%%%%%% JASON BELOW HERE %%%%%%%%%%%%
Before discussing the intricacies of the design of sympy.physics.mechanics, we
will discuss how to acquire this software and other parts of the scientific
Python software stack; we also discuss where to learn about using it and
receive help.
All of these are liberally licensed using BSD or compatible; either stable
releases or development branches can be downloaded.

Each package used in this paper can be found at:
\begin{itemize}
\item SymPy: http://sympy.org/
\item NumPy: http://www.numpy.org/
\item SciPy: http://www.scipy.org/
\item matplotlib: http://matplotlib.org/
\end{itemize}
Alternatively, there are numerous software distributions which contain some or
all of these packages:
\begin{itemize}
\item Enthought: http://www.enthought.com/
\item Sage: http://www.sagemath.org/
\item Anaconda: http://continuum.io/
\item Python(x,y): http://www.pythonxy.com
\end{itemize}

One of the major requirements for code added to SymPy is that every function
and object has to be thoroughly tested and documented.
SymPy has over 88\% of its code tested by the automated unit-tests; this
ensures that no update causes regressions or breaks current functionality.
Generally, the SymPy development branch is more stable and contains less bugs
than the numbered releases.

SymPy has its documentation available online: http://docs.sympy.org/dev/.
It provides detailed instructions on installation, an introductory tutorial,
lists common mistakes, details development procedures and the internal
architecture, and contains detailed documentation for each submodule.
The sympy.physics.mechanics documentation contains over 60 pages that aim to
provide an overview of using this package and some of the math behind it.
Additionally, a wiki for PyDy has been created at www.pydy.org.
This is a user-editable guide to solving dynamics problems in Python, and
contains numerous introductory examples (from system definition to simulation),
examples of interfacing sympy.physics.mechanics with various compiled
languages, and more advanced use cases to demonstrate capabilities.
As PyDy is integrated into more university courses, the goal is to allow
students to utilize, refine, and expand the wiki page.

SymPy's symbolic manipulation library is the core of what we have written.
The majority of objects that are created when using SymPy are \verb|Expr|,
expressions.
\verb|Expr| is the class from which other symbolic objects, such as symbols,
adds and muls, or exponentials are subclasses of.
The code in sympy.physics.mechanics makes use of these objects (although our
code does not actually subclass them).
Within sympy.physics.mechanics, there are a number of objects and functions
spread out over several submodules:

\begin{itemize}
    \item essential.py
        This module contains the basic building blocks for working
        with vector calculus and dynamic systems.
        \begin{itemize}
            \item ReferenceFrame: this class represents rotational reference
            frames for dynamic systems. ReferenceFrame has three orthonormal
            basis unit vectors and manages information about its orientation,
            angular velocity, and angular accelartion relative to other
            reference frames through a direction cosine matrix. It is closely
            tied to Vector - Vectors have associated ReferenceFrame's and
            ReferenceFrames's have associated Vector's.
            \item Vector: this class represents a general vector made up of
            components in multiple ReferenceFrames.  Vectors support all of the
            common operations such as addition, subtraction, multiplication,
            division, dot products, cross products, and re-expression into
            different ReferenceFrames.
            \item Dyadic
            \item dynamicsymbols
        \end{itemize}
    \item point.py
    \item functions.py
    \item particle.py
    \item rigidbody.py
    \item kane.py
    \item lagrange.py
\end{itemize}

%%%%%%%%%%%% JASON ABOVE HERE %%%%%%%%%%%%
%%%%%%%%%%%% GILBERT BELOW HERE %%%%%%%%%%

%%%%%%%%%%%% GILBERT ABOVE HERE %%%%%%%%%%
%%%%%%%%%%%% ANGADH BELOW HERE %%%%%%%%%%%

%%%%%%%%%%%% ANGADH ABOVE HERE %%%%%%%%%%%

\section*{CONCLUSIONS}

\bibliographystyle{asmems4}
\bibliography{asme2e}
\end{document}
