%%%%%%%%%%%%%%%%%%%%%%%%%%% asme2e.tex %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Template for producing ASME-format articles using LaTeX            %
% Written by   Harry H. Cheng                                        %
%              Integration Engineering Laboratory                    %
%              Department of Mechanical and Aeronautical Engineering %
%              University of California                              %
%              Davis, CA 95616                                       %
%              Tel: (530) 752-5020 (office)                          %
%                   (530) 752-1028 (lab)                             %
%              Fax: (530) 752-4158                                   %
%              Email: hhcheng@ucdavis.edu                            %
%              WWW:   http://iel.ucdavis.edu/people/cheng.html       %
%              May 7, 1994                                           %
% Modified: February 16, 2001 by Harry H. Cheng                      %
% Modified: January  01, 2003 by Geoffrey R. Shiflett                %
% Use at your own risk, send complaints to /dev/null                 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%% use twocolumn and 10pt options with the asme2e format
\documentclass[twocolumn,10pt]{asme2e}
\special{papersize=8.5in,11in}

%% The class has several options
%  onecolumn/twocolumn - format for one or two columns per page
%  10pt/11pt/12pt - use 10, 11, or 12 point font
%  oneside/twoside - format for oneside/twosided printing
%  final/draft - format for final/draft copy
%  cleanfoot - take out copyright info in footer leave page number
%  cleanhead - take out the conference banner on the title page
%  titlepage/notitlepage - put in titlepage or leave out titlepage
%  
%% The default is oneside, onecolumn, 10pt, final

%%% Replace here with information related to your conference
\confshortname{IDETC/CIE 2013}
\conffullname{the ASME 2013 International Design Engineering Technical Conferences \&\\
              Computers and Information in Engineering Conference}

%%%%% for date in a single month, use
%\confdate{24-28}
%\confmonth{September}
%%%%% for date across two months, use
\confdate{4-7}
\confdate{August}
\confyear{2013}
\confcity{Portland}
\confcountry{USA}

%%% Replace DETC2009/MESA-12345 with the number supplied to you
%%% by ASME for your paper.
\papernum{IDETC/CIE 2013-13470}

%%% You need to remove 'DRAFT: ' in the title for the final submitted version.
\title{DRAFT: Constrained Multibody Dynamics with Python: From Symbolic
Equation Generation to Publication}

%%% first author
\author{Gilbet Gede\thanks{Address all correspondence to this author}, Dale L.
Peterson, Jason K. Moore, Angadh S. Nanjangud, Mont Hubbard
  \affiliation{
	  Sports Biomechanics Laboratory\\
    Department of Mechanical and Aerospace Engineering\\
    University of California\\
    Davis, California 95616\\
    Email: \{ggede, dlpeterson, jkmoor, asnanjangud, mhubbard\}@ucdavis.edu
  }
}

\begin{document}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{abstract}
Abstract goes here.
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{INTRODUCTION}
There are many dynamic systems which can be better or more effectively studied
when their equations of motion (EoM) are accessible in a symbolic form. For
equations that are interpretable by a human’s eye (i.e. of reasonable length),
symbolics are generally preferable because the interrelations of the variables
and constants can give clear understanding to the nature of the problem without
the need for numerical simulation. Many classic problems fit this category,
such as the mass-spring-damper, double pendulum, rolling disc, rattleback, and
tippy-top. The benefits of symbolic equations of motion are not limited to
these basic problems though. Certain larger, more complicated multibody systems
can also be studied more effectively when the equations of motion are available
symbolically. Advanced simplification routines can help reduced the equations
to a human readable form and even if the final equations of motion are too
lengthy for human consumption, the symbolic nature of the intermediate steps to
get to the equation of motion are generally short enough that symbolic checks
can validate the correctness of the derivation. Complex problems regarding
biomechanics, spacecraft dynamics, and single-track vehicles have all been
studied using symbolically formed equations of motion.

Having the symbolic equations of motion available allows for the simulation
just as numerical derivations do, but also allows for a more basic study of the
system in question. It becomes possible to parametrically study system behavior
by examining coefficients in the differential equations, equilibrium points,
and system stability. The symbolic form also allows for more complicated tasks,
such as analyzing how infinitesimal changes in system parameters (masses,
lengths, inertias) affect the dynamics, studying lumped parameter
discretization sizing, and analyzing how coordinate choices affect problem
complexity or configuration singularities. It also becomes possible to share
the equations of motion in a “written” form to other individuals for
collaboration, validation, or comparison reasons. This includes the ease of
sharing with other software packages for multi-domain or hardware-in-the-loop
simulation or for use in optimization or optimal control problems.

Before adequate computing technology was available, the equations of motion for
multibody dynamics problems had to be formed by hand. There are many
methodologies to obtain the correct equations of motion [Newton-Euler,
Lagrange, Kane, Hamilton, etc]. But all methods are tedious and error-prone
when derived by hand, which limits the size and complexity of systems which can
be studied. It only takes a handful of unique orientations between a small set
of rigid bodies within the system to reach this point of complexity. The
introduction of computer algebra systems (CAS) eases the difficulties in
forming the equations of motion, but does not completely eliminate them. The
details of the symbolic algebra, differentiation, and vector calculus can be
handled by a reliable CAS, eliminating the errors associated with those
operations, leaving the user to worry about the correct dynamic derivation and
less about the minor variable and sign errors. Furthermore, since the
formulation of the symbolic equations of motion is done in software, the
equations of motion are immediately available for other computations that make
use of the equations.

The software presented herein is addresses the limitations of hand derivations
and allows for the study of complex multibody dynamics problems from a symbolic
point of view. There already exist software packages which similarly meet these
limited criteria [Autolev/MotionGenesis, AutoSim/VehicleSim, others?]. But when
developing our software, we also included several other unique requirements:
\begin{itemize}
  \item The software should be open source with a liberal software license and
    developed collaboratively allowing for others to improve the functionality
    and features. This will allow continued project development which is not
    limited to or controlled by one individual or company and allow easy
    integration and use by other projects.
   \item Develop the software in an existing popular high level programming
     language which has access to a large array of software packages. This will
     allow for greater flexibility and power when end-users are working with
     our software due to the ability to use only one programming language for
     all of their needs or easy integration with other languages and software
     packages.
   \item The software should be built on top of a full-featured CAS with
     many symbolic libraries allowing for more options in defining functions
     and variables and more operations which can be performed on scalar or
     matrix quantities.
   \item The ability to easily transfer equations out of the software allowing
     for publication-friendly equation writing and formatting symbolic terms
     for other computing languages.
\end{itemize}
To meet these criteria, we selected Python as the base programming language.
Python is open source, high level, easy to learn, widely available, cross
platform, has a large scientific user base [SciPy,NumFocus or something in
particular?], and has a popular and actively developed computer algebra system,
SymPy [cite sympy]. The software package SymPy provides a symbolic manipulation
library which we used as the basis for generating symbolic equations of motion.
By including our code with SymPy, we’ve hopefully ensured the longevity and
wide use of software. SymPy is part of the SciPy Stack specification, so it is
included with all scientific python distributions including popular ones such
as Enthought, Sage, Anaconda, and Python(x,y). SymPy is one of the more
actively developed Python packages with a large number of maintainers, with a
likely long future ahead of it. The SymPy development model allowed us to
include whatever functionality we needed and allow for other users to view our
code, suggest additional abilities, and improve upon and add to what we have
already done.

Within this paper, we will discuss two main topics: the first is the EoM
generation Python package, sympy.physics.mechanics, which is sub-package in
SymPy and secondly, the overall workflow for analyzing multibody dynamic
systems from derivation to simulation and visualization, which we call PyDy, an
acronym for Python Dynamics. We will explore these two topics through an
explanation of the software design and by demonstrating a test problem which
displays software functionality and usage, how our software is incorporated
into a workflow for analyzing dynamic systems, and the results of these
processes. We will then discuss a number of other features, internal
constructions within our software, and verification with benchmark examples.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{DEMONSTRATION PROBLEM}
To demonstrate the value of PyDy, we have chosen a test problem which
demonstrates its strengths.
The problem is shown in figure (X).
It is a N-pendulum system - a series of N masses each connected by masses links
subjected to a gravitational field.

(Make a figure)

We picked this problem because it is non-trivial, demonstrates the benefits of
having the EoM generation code being written in a full-featured programming
language, and can be written concisely.
When writing the problem by hand, the angular velocity of each and every link
needs to be found, as well as the velocity of each connection.
As the velocity of each connecting point is built off the previous links
connecting point, each additional link has an increasingly large velocity (in
terms of expression size) associated with it.
This is briefly shown in equations (x through x).
(write equation for ang vel and vel, for a few connected links)

When using our software to generate the EoM, the user needs to set the angular
velocity of each link’s reference frame relative to another reference frame,
they need to use a function to find the velocity of each point as a function of
the previous points velocity, list the gravitational forces for each body, and
then supply the problem to the object which generates the EoM.
This certainly sounds complicated, but the code below shows what it actually
looks like.

(code here)

The equations of motion have now been generated.
In order to do anything useful though, we need to output and examine them.
Within a console, there are commands to display the quantities generated, such
as [mpprint], which generates the output below, showing the mass matrix of this
problem with N=3:

mpprint output

There is also LaTeX output functionality, which generates a string that can be
directly copied/pasted into publications to generate LaTeX math equations (the
same mass matrix is shown):

mlatex output

Another part of studying dynamic systems is simulation and visualization of the
results.
SymPy can only solve relatively simple ODEs internally, so the equations of
motion generated for more complex systems need to be passed to other numerical
integrators.
Currently, sympy.physics.mechanics can make use of existing SymPy translation
functions, but more advanced options to generate compiled code are being
developed and guided by user demands.
The SymPy translation function [lambdify] can convert symbolic expressions to a
function using NumPy code.
The code below (which follows the previously written code) shows this:

(up to rhs function)

NumPy is an integral part of the larger Scientific Python ecosystem, focusing
primarily on numerical arrays and matrices and operations on these arrays and
matrices.
SciPy is another part of this ecosystem that provides quick and simple Python
wrappers to a large library of scientific FORTRAN code.
The third necessary component of this ecosystem is matplotlib, a Python
plotting library for visualization of the large datasets generated by NumPy and
SciPy code.
Using these three Python packages, we can numerically integrate ODEs and plot
the results.
The following code shows this process and figures (x) show the plots generated:

(last bit of code)

Using other Python packages, such as VisualPython, 3D animations can be
created.
Use of human-interface-devices (with a sufficiently fast computer) allows for
real-time interaction between a user and a visualized simulation.
\section*{SOFTWARE VALIDATION}
Anytime new software is developed to generate equations of motion, the
vailidity and accuracy of the software rightly comes into question. We have
addressed these concerns in three ways to ensure that our code does generate
correct equations of motion for arbitrarily complex systems. Firstly, the code
is open source and well documented. This allows anyone to review the code and
check for bugs. Linus's Law ``given enough eyeballs, all bugs
are shallow'' (cite the Cathedral and the Bazaat) applies, if true.
Secondly, the code functionality is heavily tested with unit testing.  That is,
each piece of independent functionality in the code has a test (known
input/output) in place that guarantees correct functioning of each unit. This
helps ensure that not only the current code works as expected, but that future
versions must also pass the tests. Thirdly, we've built in tests for well
benchmarked problems in mutlibody dynamics. There are many problems, both
simple and complex that have well known symbolic solutions. We have chosen
several benchmark problems that include three dimensional, configuration and
motion constraints, and exposing noncontributing forces. These problems are
built in to the test suite for the package.

One degree of freedom mass sprint dampero
two degree of freedom mas sping damper (two particleso
particle pendulum (kane and lagrange)
rolling disc (kane and lagrange)
rolling disc with aux speeds
inverted pendulum on a cart
disc on an inclined plane (lagrange only)
double pendulum (langragne only)
bicycle nonlinear and linear \cite{Meijaard2007} and BasuMandall2007) - not built in as a test

mechanics leverages two interdepedent methods to validate the accuracy of the
tests within sympy: ensures stability/consistency during development
benchmark validations (rolling disc, bicycle, other\ldots)
%
\section*{SOFTWARE DESIGN}
The software design is influenced by both the underlying SymPy data types and
Kane’s method for generating equations of motion for multibody systems. Kane’s
method powers many of the dynamic system software packages available [cite
which ones] due to its ease of programmability and detailed bookkeeping
structure. Kane’s method influenced the design a great deal but we structured
the software such that any equation of motion derivation method could be used
and have recently included Lagrange’s method to demonstrate that ability. We
did this by separating the kinematics derivation from the equations of motion
generation. The package includes seven modules:
\subsection*{essential.py}
The essential.py module contains the basic building blocks for working with
vector calculus and dynamic systems.

The ReferenceFrame class represents the concept of an inertial reference frame
in a dynamic system. The ReferenceFrame has three orthonormal basis unit
vectors and manages information about its orientation, angular velocity, and
angular accelartion relative to other reference frames through a direction
cosine matrix.

The Vector class represents a general vector in a reference frame. Vectors are
represented by measure numbers in the three basic vectors of a reference frame.
Vectors support all of the common operations such as addition, subtraction,
multiplication, division, dot products, cross products, and expression in
different reference frames.

The dyadic represents a
\subsection*{point.py}
The point module contains a Point class that manages location information of a
single point within a reference frame.
\subsection*{particle.py}
The Particle class adds the concept of mass to a Point object.
\subsection*{rigidbody.py}
A RigidBody object contains a ReferenceFrame, mass, inertia dyadic, mass
center.
\subsection*{kane.py}
The Kane class automatically generates the equations of motion for a collection
of rigid bodies, particles, forces, torques, constraints, auxilary speeds.
\subsection*{lagrange.py}
blank
\subsection*{functions.py}
The functions module provides several

talk about the modules and object model, maybe generate a UML

talk about the documentation (both sympy docs, pydy.org, and pydy examples repo)

Before addressing details of the software we have written, it should be
mentioned how the various parts of PyDy can be acquired.
SymPy: http://sympy.org/
NumPy: http://www.numpy.org/
SciPy: http://www.scipy.org/
matplotlib: http://matplotlib.org/
All of these are liberally licensed using BSD or compatible; either stable
releases or development branches can be downloaded.
While these Python modules are maintained by different groups, but there are
also some packages which combine them:
[list them]

The packages
\bibliographystyle{asmems4}
\bibliography{asme2e}
\end{document}
